
## 1. Classe `SecurityConfig`

C‚Äôest la **configuration de s√©curit√© principale** de 
### a. Gestion des sessions

```java
http.sessionManagement(management -> management.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
```

‚û°Ô∏è `STATELESS` = pas de session c√¥t√© serveur (pas de cookie de session).
Chaque requ√™te doit fournir un **JWT valide**.

---

### b. R√®gles d‚Äôacc√®s

```java
.authorizeHttpRequests(authorize -> authorize
    .requestMatchers("/api/**").authenticated()
    .requestMatchers("/api/super-admin/**").hasRole("ADMIN")
    .anyRequest().permitAll()
)
```

‚û°Ô∏è Les r√®gles :

* `/api/**` ‚Üí doit √™tre authentifi√© (avoir un JWT valide).f"""'
* `/api/super-admin/**` ‚Üí doit √™tre authentifi√© **et** avoir le r√¥le **ADMIN**.
* Le reste (`anyRequest()`) ‚Üí accessible √† tout le monde.

---

### c. Ajout d‚Äôun filtre

```java
.addFilterBefore(new JwtValidator(), BasicAuthenticationFilter.class)
```

‚û°Ô∏è Tu ajoutes un filtre perso (`JwtValidator`) qui lit et valide le **JWT** avant le filtre d‚Äôauthentification de Spring.

---

### d. CSRF et CORS

```java
.csrf(AbstractHttpConfigurer::disable)
.cors(cors -> cors.configurationSource(corsConfigurationSource()))
```

* `csrf` d√©sactiv√© (utile car tu bosses en REST API).
* `corsConfigurationSource()` ‚Üí autorise uniquement `http://localhost:5173` (ton front React s√ªrement).

---

## 2. Classe `JwtValidator`

C‚Äôest ton **filtre JWT**, qui h√©rite de `OncePerRequestFilter` (donc ex√©cut√© **une fois par requ√™te**).

```java
String jwt = request.getHeader(JwtConstant.JWT_HEADER);
```

‚û°Ô∏è R√©cup√®re le header `Authorization`.

Si le token existe :

1. Il enl√®ve le pr√©fixe `Bearer ` avec `jwt.substring(7)`.
2. Il v√©rifie et d√©code le JWT avec la cl√© secr√®te.
3. R√©cup√®re les infos :

   * `email` du user
   * `authorities` (r√¥les sous forme de string s√©par√©s par virgules).
4. Transforme √ßa en **objet Authentication** :

   ```java
   Authentication auth = new UsernamePasswordAuthenticationToken(email, null, auths);
   SecurityContextHolder.getContext().setAuthentication(auth);
   ```

   üëâ Maintenant Spring sait **qui est connect√©** et ses **r√¥les**.

Si probl√®me ‚Üí `BadCredentialsException("Invalid JWT token")`.

---

## 3. Classe `JwtProvided`

C‚Äôest le **service qui g√©n√®re les JWT**.

### a. G√©n√©ration de token

```java
public String generateToken(Authentication authentication) {
    Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
    String roles = populateAuthorities(authorities);

    return Jwts.builder()
            .issuedAt(new Date())
            .expiration(new Date(new Date().getTime()+ 86400000)) // 1 jour
            .claim("email", authentication.getName())
            .claim("authorities", roles)
            .signWith(key)
            .compact();
}
```

‚û°Ô∏è Le token contient :

* `email`
* `authorities` (les r√¥les, genre `"ROLE_USER,ROLE_ADMIN"`)
* une date d‚Äôexpiration (24h).

---

### b. Extraction email depuis le token

```java
public String getEmailFromToken(String jwt) { ... }
```

‚û°Ô∏è R√©cup√®re uniquement la claim `email` depuis un token.

---

### c. M√©thode utilitaire

```java
private String populateAuthorities(Collection<? extends GrantedAuthority> authorities)
```

‚û°Ô∏è Convertit une liste de r√¥les en une string s√©par√©e par des virgules.

---

## 4. Classe `JwtConstant`

```java
public class JwtConstant {
    public static final String JWT_SECRET= "rhzfiozehfezfhzeifohdhfiizohfeiohzidfhoizehfi";
    public static final String JWT_HEADER = "Authorization";
}
```

‚û°Ô∏è Contient :

* la **cl√© secr√®te** pour signer et v√©rifier les tokens (‚ö†Ô∏è en prod ‚Üí jamais en clair dans le code, utilise un fichier de config ou variable d‚Äôenvironnement).
* le nom du header ‚Üí `"Authorization"`.

---

## üîé R√©sum√© global

Ton syst√®me fonctionne comme √ßa :

1. **Un utilisateur se connecte** (via login classique) ‚Üí Spring g√©n√®re un **JWT** avec `JwtProvided`.
2. Le front stocke ce token (souvent dans `localStorage`) et l‚Äôenvoie dans les requ√™tes avec le header :

   ```
   Authorization: Bearer <JWT>
   ```
3. √Ä chaque requ√™te sur `/api/**`, ton filtre `JwtValidator` :

   * lit le header,
   * valide la signature et la date,
   * extrait email + r√¥les,
   * stocke √ßa dans `SecurityContextHolder` pour que Spring sache qui fait la requ√™te.
4. Spring Security applique les r√®gles :

   * `/api/**` ‚Üí besoin d‚Äôun JWT valide,
   * `/api/super-admin/**` ‚Üí JWT valide **et** r√¥le ADMIN,
   * autres ‚Üí public.

---

Veux-tu que je te fasse un **sch√©ma de fonctionnement (flowchart)** de tout le cycle (connexion ‚Üí g√©n√©ration ‚Üí validation du JWT) pour que ce soit encore plus clair visuellement ?
